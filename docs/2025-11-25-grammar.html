<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çŒ«å¤´é¹°æ–‡æ³•</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" rel="stylesheet">
    <style>
        /* --- åŸºç¡€è®¾ç½® --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* é˜²æ­¢æ•´é¡µæ»šåŠ¨ */
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: #f0f2f5;
            color: #333;
        }

        /* --- æ•´ä½“ç½‘æ ¼å¸ƒå±€ --- */
        .app-container {
            display: grid;
            grid-template-rows: auto 1fr; /* é¡¶éƒ¨è‡ªé€‚åº”ï¼Œåº•éƒ¨å¡«æ»¡ */
            grid-template-columns: 400px 1fr; /* å·¦ä¾§ç¨å®½ä»¥å®¹çº³å¤æ‚æŒ‰é’®ï¼Œå³ä¾§è‡ªé€‚åº” */
            height: 100vh;
            width: 100vw;
        }

        /* --- é¡¶éƒ¨é€šæ  (æ ‡é¢˜ + è¾“å…¥) --- */
        .top-bar {
            grid-column: 1 / -1;
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 10;
            border-bottom: 1px solid #e0e0e0;
        }

        .brand {
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 200px;
        }

        .input-group {
            flex: 1;
            display: flex;
            gap: 10px;
            justify-content: center;
            max-width: 900px;
        }

        input {
            padding: 8px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            max-width: 500px;
            font-size: 14px;
        }

        button {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            background: #4CAF50;
            color: white;
            transition: background 0.2s;
            white-space: nowrap;
        }
        button:hover { background: #45a049; }
        button.secondary { background: #2196F3; }
        button.secondary:hover { background: #1976D2; }

        /* --- å·¦ä¾§è¾¹æ  (ä¿¡æ¯æ˜¾ç¤º) --- */
        .sidebar {
            background: #fafafa;
            border-right: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto; /* å†…å®¹å¤šæ—¶å†…éƒ¨æ»šåŠ¨ */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .card {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #eee;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        h3 {
            margin: 0 0 10px 0;
            font-size: 15px;
            color: #444;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 5px;
        }

        /* æ–‡æ³•è§„åˆ™å¾®ç¼© */
        .grammar-rules p {
            margin: 3px 0;
            font-size: 12px;
            color: #666;
            font-family: monospace;
        }

        /* è¯­ä¹‰ç»“æœå¡ç‰‡ä¼˜åŒ– */
        .semantic-result {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }
        .body-part {
            flex: 1;
            text-align: center;
            padding: 8px 4px;
            border-radius: 4px;
            border: 1px solid;
        }
        .head { background: #e3f2fd; border-color: #90caf9; }
        .body { background: #f3e5f5; border-color: #ce93d8; }

        .part-label { font-size: 11px; color: #555; margin-bottom: 2px; }
        .part-value { font-size: 16px; font-weight: bold; color: #d32f2f; margin: 2px 0; }
        .part-source { font-size: 11px; color: #888; }

        #semanticExplanation {
            font-size: 12px;
            color: #555;
            line-height: 1.4;
            background: #fff8e1;
            padding: 8px;
            border-radius: 4px;
        }
        #semanticExplanation ul { margin: 5px 0; padding-left: 20px; }

        /* æ¨å¯¼è¿‡ç¨‹åˆ—è¡¨ */
        #derivation {
            font-size: 12px;
            max-height: 200px; /* é™åˆ¶é«˜åº¦ï¼Œç•™ç»™ç¤ºä¾‹æŒ‰é’® */
            overflow-y: auto;
        }
        #derivation ol { padding-left: 25px; margin: 0; }
        #derivation li { margin-bottom: 4px; color: #555; }

        /* çŠ¶æ€æ¶ˆæ¯ */
        .error { color: #d32f2f; background: #ffebee; padding: 8px; border-radius: 4px; font-size: 12px; }
        .success { color: #2e7d32; background: #e8f5e8; padding: 8px; border-radius: 4px; font-size: 12px; }

        /* ç¤ºä¾‹æŒ‰é’®ç½‘æ ¼ - é’ˆå¯¹é•¿æ–‡æœ¬ä¼˜åŒ– */
        .examples-grid {
            display: grid;
            grid-template-columns: 1fr; /* æ”¹ä¸ºå•åˆ—ï¼Œé˜²æ­¢é•¿æ–‡æœ¬æŒ¤å‹ */
            gap: 6px;
        }
        .example-btn {
            font-size: 11px;
            padding: 6px;
            background: #ff9800;
            text-align: left;
            white-space: normal; /* å…è®¸æ¢è¡Œ */
            line-height: 1.2;
            word-break: break-all;
        }
        .example-btn:hover { background: #fb8c00; }

        .category-title {
            font-weight: bold;
            font-size: 12px;
            margin: 8px 0 4px 0;
            color: #555;
        }

        /* --- å³ä¾§ä¸»åŒºåŸŸ (å¯è§†åŒ–) --- */
        .main-panel {
            position: relative;
            background: white;
            padding: 0;
            overflow: hidden;
        }

        #syntaxTree {
            width: 100%;
            height: 100%; /* å¡«æ»¡å‰©ä½™ç©ºé—´ */
            border: none;
        }

        .vis-label {
            background: rgba(255,255,255,0.9);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 5;
            pointer-events: none;
            border: 1px solid #ddd;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        div.vis-network div.vis-tooltip {
            z-index: 100; /* ä¿è¯æç¤ºæ¡†åœ¨ä¸Šå±‚ */
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- é¡¶éƒ¨æ  -->
        <div class="top-bar">
            <div class="brand">çŒ«å¤´é¹°æ–‡æ³•</div>
            <div class="input-group">
                <input type="text" id="inputText" placeholder="è¾“å…¥ç”Ÿç‰©åˆæˆè¯ï¼Œå¦‚ï¼šçŒ«å¤´é¹°å¤´çŒ«" value="çŒ«å¤´é¹°å¤´çŒ«">
                <button onclick="parseInput()">è§£æ</button>
                <button onclick="showRandomExample()" class="secondary">ğŸ² éšæœºæµ‹è¯•</button>
                <button onclick="showAllExamples()" class="secondary">ğŸ“š å¤æ‚ç¤ºä¾‹åº“</button>
            </div>
        </div>

        <!-- å·¦ä¾§è¾¹æ  -->
        <div class="sidebar">
            <!-- 1. æ–‡æ³•è§„åˆ™ -->
            <div class="card grammar-rules">
                <h3>ğŸ“œ è§„åˆ™å®šä¹‰</h3>
                <p><strong>N â†’ B | N H B</strong> (å·¦ç»“åˆ)</p>
                <p><strong>B â†’ "çŒ«" | "é¹°" | "çŒ«å¤´é¹°"</strong></p>
                <p><strong>H â†’ "å¤´"</strong></p>
                <p style="margin-top:5px; color:#1976D2">è¯­ä¹‰ï¼šå¤´=å·¦.å¤´, èº«=å³.èº«</p>
            </div>

            <!-- 2. æ¶ˆæ¯ä¸ç¤ºä¾‹åŒºåŸŸ -->
            <div id="message"></div>

            <!-- 3. è¯­ä¹‰åˆ†æç»“æœ -->
            <div class="card" id="semanticResult" style="display: none;">
                <h3>ğŸ§¬ è¯­ä¹‰åˆ†æç»“æœ</h3>
                <div class="semantic-result">
                    <div class="body-part head">
                        <div class="part-label">æœ€ç»ˆå¤´éƒ¨</div>
                        <div class="part-value" id="headValue"></div>
                        <div class="part-source">æºè‡ª: <span id="headSource"></span></div>
                    </div>
                    <div class="body-part body">
                        <div class="part-label">æœ€ç»ˆèº«ä½“</div>
                        <div class="part-value" id="bodyValue"></div>
                        <div class="part-source">æºè‡ª: <span id="bodySource"></span></div>
                    </div>
                </div>
                <div id="semanticExplanation"></div>
            </div>

            <!-- 4. æ¨å¯¼è¿‡ç¨‹ -->
            <div class="card">
                <h3>ğŸ“ æ¨å¯¼è¿‡ç¨‹</h3>
                <div id="derivation"></div>
            </div>
        </div>

        <!-- å³ä¾§å¯è§†åŒ–åŒºåŸŸ -->
        <div class="main-panel">
            <div class="vis-label">ğŸ’¡ æç¤ºï¼šæ»šè½®ç¼©æ”¾ / æ‹–æ‹½å¹³ç§» / ç‚¹å‡»èŠ‚ç‚¹</div>
            <div id="syntaxTree"></div>
        </div>
    </div>

    <script>
        class SemanticNode {
            constructor(label, value, type) {
                this.id = null;
                this.label = label;
                this.value = value;
                this.type = type;
                this.children = [];
                this.semantics = {
                    head: "", body: "", headSource: "", bodySource: "", headOrigin: "", bodyOrigin: ""
                };
            }
        }

        function tokenize(input) {
            const tokens = [];
            let i = 0;

            while (i < input.length) {
                // è®°å½•å½“å‰ç´¢å¼•ï¼Œç”¨äºç”Ÿæˆå”¯ä¸€çš„ID
                const start = i;

                if (input.startsWith('çŒ«å¤´é¹°', i)) {
                    tokens.push({ type: 'B', value: 'çŒ«å¤´é¹°', index: start });
                    i += 3;
                } else if (input.startsWith('çŒ«', i)) {
                    tokens.push({ type: 'B', value: 'çŒ«', index: start });
                    i += 1;
                } else if (input.startsWith('é¹°', i)) {
                    tokens.push({ type: 'B', value: 'é¹°', index: start });
                    i += 1;
                } else if (input.startsWith('å¤´', i)) {
                    tokens.push({ type: 'H', value: 'å¤´', index: start });
                    i += 1;
                } else {
                    // --- æ ¸å¿ƒæ”¹åŠ¨ï¼šé‡åˆ°ä¸è®¤è¯†çš„å­—ï¼Œæ ‡è®°ä¸º UNKNOWNï¼Œä¸æŠ¥é”™ ---
                    const char = input[i];
                    tokens.push({ type: 'UNKNOWN', value: char, index: start });
                    i += 1; // ç»§ç»­è¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦
                }
            }

            return tokens;
        }

        function deriveSemantics(node) {
            if (node.children.length === 0) {
                switch(node.value) {
                    case "çŒ«":
                        node.semantics = { head: "çŒ«", body: "çŒ«", headSource: "çŒ«è‡ªèº«", bodySource: "çŒ«è‡ªèº«", headOrigin: "çŒ«", bodyOrigin: "çŒ«" };
                        break;
                    case "é¹°":
                        node.semantics = { head: "é¹°", body: "é¹°", headSource: "é¹°è‡ªèº«", bodySource: "é¹°è‡ªèº«", headOrigin: "é¹°", bodyOrigin: "é¹°" };
                        break;
                    case "çŒ«å¤´é¹°":
                        node.semantics = { head: "çŒ«å¤´é¹°", body: "çŒ«å¤´é¹°", headSource: "çŒ«å¤´é¹°è‡ªèº«", bodySource: "çŒ«å¤´é¹°è‡ªèº«", headOrigin: "çŒ«å¤´é¹°", bodyOrigin: "çŒ«å¤´é¹°" };
                        break;
                }
            } else {
                const left = node.children[0];
                const right = node.children[2];
                deriveSemantics(left);
                deriveSemantics(right);
                // æ ¸å¿ƒè¯­ä¹‰è§„åˆ™ï¼šå¤´ç»§æ‰¿å·¦è¾¹ï¼Œèº«ç»§æ‰¿å³è¾¹
                node.semantics = {
                    head: left.semantics.head,
                    body: right.semantics.body,
                    headSource: left.value,
                    bodySource: right.value,
                    headOrigin: left.semantics.headOrigin,
                    bodyOrigin: right.semantics.bodyOrigin
                };
            }
            return node.semantics;
        }

        class Parser {
            constructor(tokens) {
                this.tokens = tokens;
                this.position = 0;
                this.nodes = [];
                this.nextId = 1;
            }

            get currentToken() {
                return this.position < this.tokens.length ? this.tokens[this.position] : null;
            }

            getNodes() {
                return this.nodes;
            }

            consume(expectedType) {
                if (!this.currentToken) {
                    const error = new Error(`è¯­æ³•é”™è¯¯: è¯­å¥æœªå®Œæˆï¼ŒæœŸæœ›è¾“å…¥ ${expectedType}`);
                    error.type = 'EOF';
                    throw error;
                }

                // --- æ ¸å¿ƒæ”¹åŠ¨ï¼šå¦‚æœé‡åˆ° UNKNOWNï¼ŒæŠ›å‡ºç‰¹å®šé”™è¯¯ ---
                if (this.currentToken.type === 'UNKNOWN') {
                    const token = this.currentToken;
                    const error = new Error(`è¯­æ³•é”™è¯¯: æ— æ³•è¯†åˆ«çš„å­—ç¬¦: "${token.value}"`);
                    error.token = token; // æŠŠåæ‰çš„ token ä¼ å‡ºå»
                    error.type = 'UNKNOWN_TOKEN';
                    this.position++; // å‡è£…æ¶ˆè´¹æ‰ï¼Œé¿å…æ­»å¾ªç¯ï¼ˆè™½ç„¶è¿™é‡Œä¼šthrowå‡ºå»ï¼‰
                    throw error;
                }

                // ç±»å‹åŒ¹é…
                if (this.currentToken.type === expectedType) {
                    const token = this.currentToken;
                    this.position++;
                    return token;
                }

                // ç±»å‹ä¸åŒ¹é… (ä¾‹å¦‚: æœŸæœ› B å´æ¥äº† H)
                const error = new Error(`è¯­æ³•é”™è¯¯: æœŸæœ› ${expectedType}ï¼Œä½†é‡åˆ° "${this.currentToken.value}"`);
                error.token = this.currentToken;
                error.type = 'MISMATCH';
                throw error;
            }

            parseB() {
                const token = this.consume('B');
                const node = new SemanticNode(`B: ${token.value}`, token.value, 'B');
                node.id = this.nextId++;
                this.nodes.push(node);
                return node;
            }

            parseN() {
                let left = this.parseB();

                while (this.currentToken && (this.currentToken.type === 'H' || this.currentToken.type === 'UNKNOWN')) {
                    // å¦‚æœæ˜¯ UNKNOWNï¼Œconsume('H') ä¼šè§¦å‘é”™è¯¯ï¼Œè¢«å¤–å±‚æ•è·
                    const hToken = this.consume('H');

                    const hNode = new SemanticNode(`H: ${hToken.value}`, hToken.value, 'H');
                    hNode.id = this.nextId++;
                    this.nodes.push(hNode);

                    const right = this.parseB();

                    const node = new SemanticNode(
                        `N: ${left.value}å¤´${right.value}`,
                        left.value + 'å¤´' + right.value,
                        'N'
                    );
                    node.id = this.nextId++;
                    node.children = [left, hNode, right];
                    this.nodes.push(node);
                    left = node;
                }
                return left;
            }

            parse() {
                const root = this.parseN();
                // æ£€æŸ¥å‰©ä½™éƒ¨åˆ†
                if (this.position < this.tokens.length) {
                    // å¦‚æœå‰©ä¸‹çš„æ˜¯ UNKNOWNï¼Œæˆ–è€…å¤šä½™çš„æœ‰æ•ˆ Token
                    const token = this.currentToken;
                    const msg = token.type === 'UNKNOWN' ?
                        `æ— æ³•è¯†åˆ«çš„å­—ç¬¦: "${token.value}"` :
                        `æ„å¤–çš„å¤šä½™å†…å®¹: "${token.value}"`;

                    const error = new Error(msg);
                    error.token = token;
                    error.type = 'EXTRA';
                    throw error;
                }
                deriveSemantics(root);
                return root;
            }
        }

        function parseInput() {
            const input = document.getElementById('inputText').value.trim();
            const messageDiv = document.getElementById('message');
            const derivationDiv = document.getElementById('derivation');
            const semanticResult = document.getElementById('semanticResult');

            messageDiv.innerHTML = '';
            derivationDiv.innerHTML = '';
            semanticResult.style.display = 'none';

            let parser = null;
            let nodes = [];

            try {
                if (!input) throw new Error("è¯·è¾“å…¥å†…å®¹");

                const tokens = tokenize(input); // è¿™ä¸€æ­¥ç°åœ¨æ°¸è¿œä¸ä¼šæŠ¥é”™äº†
                parser = new Parser(tokens);

                const root = parser.parse();
                nodes = parser.getNodes();

                // --- æˆåŠŸ ---
                messageDiv.innerHTML = `<div class="success">âœ… è§£ææˆåŠŸ</div>`;
                displaySemanticResult(root, input);

                // æ˜¾ç¤ºæ¨å¯¼
                let derivation = '<ol>';
                nodes.forEach(node => {
                    if (node.type === 'N' && node.children.length > 0) derivation += `<li>N â†’ N H B â†’ ${node.label.split(':')[1]}</li>`;
                    else if (node.type === 'B') derivation += `<li>B â†’ ${node.label.split(':')[1]}</li>`;
                });
                derivation += '</ol>';
                derivationDiv.innerHTML = derivation;

                visualizeTree(nodes);

            } catch (error) {
                // --- é”™è¯¯å¯è§†åŒ–å¤„ç† ---
                console.error(error);

                // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
                messageDiv.innerHTML = `<div class="error">âŒ ${error.message}</div>`;

                if (parser) {
                    // 1. è·å–å·²ç»æˆåŠŸè§£æçš„èŠ‚ç‚¹
                    nodes = parser.getNodes();

                    // 2. å¦‚æœé”™è¯¯åŒ…å« token ä¿¡æ¯ï¼Œåˆ›å»ºä¸€ä¸ªâ€œé”™è¯¯èŠ‚ç‚¹â€
                    if (error.token) {
                        nodes.push({
                            id: `error_${error.token.index}`, // å”¯ä¸€ID
                            label: `${error.message}`, // æ˜¾ç¤ºå‡ºé”™çš„å­—
                            type: 'ERROR',
                            value: error.token.value,
                            title: error.message // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºåŸå› 
                        });

                        // 3. (å¯é€‰) æŠŠé”™è¯¯èŠ‚ç‚¹åé¢çš„æ‰€æœ‰å‰©ä½™ Token ä¹Ÿç”»å‡ºæ¥ï¼Œæ˜¾ç¤ºä¸ºç°è‰²
                        // è¿™æ ·ç”¨æˆ·èƒ½çœ‹åˆ°æ•´ä¸ªå¥å­å“ªé‡Œæ–­äº†ï¼Œåé¢è¿˜æœ‰ä»€ä¹ˆ
                        const currentIdx = parser.tokens.indexOf(error.token);
                        if (currentIdx !== -1) {
                            for (let i = currentIdx + 1; i < parser.tokens.length; i++) {
                                const t = parser.tokens[i];
                                nodes.push({
                                    id: `skip_${t.index}`,
                                    label: t.value,
                                    type: 'SKIPPED', // æ–°ç±»å‹ï¼šè¢«è·³è¿‡çš„
                                    value: t.value
                                });
                            }
                        }
                    } else if (error.type === 'EOF') {
                        // å¦‚æœæ˜¯è¯­å¥æœªå®Œæˆï¼Œç”»ä¸€ä¸ªé—®å·èŠ‚ç‚¹
                        nodes.push({
                            id: 'eof_node',
                            label: `${error.message}`,
                            type: 'ERROR',
                            title: 'æœŸå¾…æ›´å¤šè¾“å…¥'
                        });
                    }

                    // æ¸²æŸ“åŒ…å«é”™è¯¯èŠ‚ç‚¹çš„æ ‘
                    visualizeTree(nodes);
                } else {
                    document.getElementById('syntaxTree').innerHTML = '';
                }
            }
        }

        function displaySemanticResult(root, input) {
            const semanticResult = document.getElementById('semanticResult');
            const semantics = root.semantics;

            document.getElementById('headValue').textContent = semantics.head;
            document.getElementById('bodyValue').textContent = semantics.body;
            document.getElementById('headSource').textContent = semantics.headSource;
            document.getElementById('bodySource').textContent = semantics.bodySource;

            let explanation = `<div style="margin-top:5px"><strong>åˆæˆé€»è¾‘ï¼š</strong></div>`;
            explanation += `<ul>`;
            explanation += `<li>å¤´éƒ¨ç»§æ‰¿è‡ªæœ€å·¦ä¾§çš„ï¼š${semantics.headOrigin}</li>`;
            explanation += `<li>èº«ä½“ç»§æ‰¿è‡ªæœ€å³ä¾§çš„ï¼š${semantics.bodyOrigin}</li>`;
            explanation += `</ul>`;

            document.getElementById('semanticExplanation').innerHTML = explanation;
            semanticResult.style.display = 'block';
        }

        function visualizeTree(nodes) {
            const container = document.getElementById('syntaxTree');
            container.innerHTML = '';
            const visNodes = new vis.DataSet();
            const visEdges = new vis.DataSet();

            const existingIds = new Set(nodes.map(n => n.id));

            nodes.forEach(node => {
                let color = '#E3F2FD';
                let fontColor = '#333';
                let shape = 'box';
                let label = node.label;
                let borderDashes = false;

                // --- æ ·å¼å®šä¹‰ ---
                if (node.type === 'ERROR') {
                    color = '#FFEBEE';       // æµ…çº¢èƒŒæ™¯
                    fontColor = '#D32F2F';   // æ·±çº¢æ–‡å­—
                    label = node.label;      // ç›´æ¥æ˜¾ç¤ºå¸¦âŒçš„æ ‡ç­¾
                    shape = 'box';
                }
                else if (node.type === 'SKIPPED') {
                    color = '#F5F5F5';       // æµ…ç°èƒŒæ™¯
                    fontColor = '#999';      // ç°è‰²æ–‡å­—
                    borderDashes = true;     // è™šçº¿è¾¹æ¡†
                    label = node.value;
                }
                else if (node.type === 'B') {
                    color = '#C8E6C9';
                    label = node.label.includes(':') ? node.label.split(':')[1].trim() : node.label;
                }
                else if (node.type === 'N') {
                    if (node.semantics && node.semantics.head) {
                        color = '#FFF9C4';
                        let val = node.value;
                        if(val.length > 10) val = val.substring(0,8) + '..';
                        label = val + `\n[å¤´:${node.semantics.head}]`;
                    }
                }
                else if (node.type === 'H') {
                    color = '#F5F5F5';
                    label = 'å¤´';
                }

                visNodes.add({
                    id: node.id,
                    label: label,
                    shape: shape,
                    color: {
                        background: color,
                        border: node.type === 'ERROR' ? '#D32F2F' : '#999'
                    },
                    shapeProperties: { borderDashes: borderDashes }, // è™šçº¿æ”¯æŒ
                    font: { multi: true, size: 14, color: fontColor },
                    shadow: true,
                    title: node.title || node.value // Tooltip
                });

                // åªæœ‰æ­£å¸¸çš„èŠ‚ç‚¹æ‰æœ‰è¿çº¿
                if (node.children) {
                    node.children.forEach(child => {
                        if (existingIds.has(child.id)) {
                            visEdges.add({ from: node.id, to: child.id, arrows: 'to', color: {color:'#ccc'} });
                        }
                    });
                }
            });

            // è¿™é‡Œæœ‰ä¸ªå°æŠ€å·§ï¼šä¸ºäº†è®©é”™è¯¯èŠ‚ç‚¹å¥½çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯•æŠŠ Error èŠ‚ç‚¹å’Œæœ€è¿‘çš„ä¸€ä¸ªèŠ‚ç‚¹è¿ä¸€æ¡çº¢è‰²çš„è™šçº¿
            // ä½†ç®€å•çš„åšæ³•æ˜¯è®©å®ƒä»¬è‡ªç„¶æ’åˆ—ï¼ŒVis.js ä¼šè‡ªåŠ¨å¤„ç†

            // å¦‚æœå­˜åœ¨ ERROR èŠ‚ç‚¹ï¼ŒæŸ¥æ‰¾æ˜¯å¦å¯ä»¥è¿æ¥åˆ°æœ€åçš„æœ‰æ•ˆèŠ‚ç‚¹ï¼ˆå¯é€‰ä¼˜åŒ–ï¼‰
            // ç®€å•èµ·è§ï¼Œæˆ‘ä»¬ä¸åŠ é¢å¤–çš„è¾¹ï¼Œè®©é”™è¯¯èŠ‚ç‚¹æµ®åŠ¨åœ¨æ—è¾¹å³å¯

            const data = { nodes: visNodes, edges: visEdges };
            const options = {
                layout: {
                    hierarchical: {
                        direction: 'UD',
                        sortMethod: 'directed',
                        levelSeparation: 100,
                        nodeSpacing: 150,
                        blockShifting: true,
                        edgeMinimization: true,
                        parentCentralization: true
                    }
                },
                physics: false,
                interaction: { dragNodes: true, zoomView: true, dragView: true }
            };
            new vis.Network(container, data, options);
        }

        function showRandomExample() {
            // æ‰å¹³åŒ–çš„æ‰€æœ‰ç¤ºä¾‹åº“ï¼Œç”¨äºéšæœºæŠ½å–
            const allSamples = [
                // åŸºç¡€
                'çŒ«', 'é¹°', 'çŒ«å¤´é¹°',
                // ç®€å•
                'é¹°å¤´çŒ«', 'çŒ«å¤´é¹°å¤´çŒ«', 'çŒ«å¤´çŒ«', 'é¹°å¤´é¹°',
                // ä¸­ç­‰
                'çŒ«å¤´çŒ«å¤´é¹°', 'é¹°å¤´çŒ«å¤´é¹°', 'çŒ«å¤´é¹°å¤´é¹°', 'é¹°å¤´é¹°å¤´çŒ«',
                // å¤æ‚
                'çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°', 'é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«', 'çŒ«å¤´é¹°å¤´é¹°å¤´çŒ«å¤´çŒ«',
                // å˜æ€
                'çŒ«å¤´çŒ«å¤´çŒ«å¤´çŒ«å¤´é¹°',
                'é¹°å¤´é¹°å¤´é¹°å¤´é¹°å¤´çŒ«',
                'çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°',
                'é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°'
            ];

            const randomExample = allSamples[Math.floor(Math.random() * allSamples.length)];
            document.getElementById('inputText').value = randomExample;
            parseInput();
        }

        function showAllExamples() {
            const categories = {
                'ğŸ£ åŸºç¡€ç”Ÿç‰© (åŸå­)': [
                    'çŒ«',
                    'é¹°',
                    'çŒ«å¤´é¹°'
                ],
                'ğŸ§ª åˆçº§åˆæˆ (å…¥é—¨)': [
                    'é¹°å¤´çŒ«',
                    'çŒ«å¤´é¹°å¤´çŒ«',
                    'çŒ«å¤´çŒ«',
                    'é¹°å¤´é¹°å¤´é¹°'
                ],
                'ğŸ”„ é€’å½’å¾ªç¯ (å¥—å¨ƒ)': [
                    'çŒ«å¤´çŒ«å¤´çŒ«å¤´çŒ«',
                    'é¹°å¤´é¹°å¤´é¹°å¤´é¹°',
                    'çŒ«å¤´é¹°å¤´é¹°å¤´é¹°å¤´é¹°',
                    'çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°',
                    'é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«',
                    'çŒ«å¤´é¹°å¤´é¹°å¤´çŒ«å¤´çŒ«',
                    'çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«',
                    'é¹°å¤´é¹°å¤´çŒ«å¤´çŒ«å¤´é¹°å¤´é¹°å¤´çŒ«',
                    'çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«å¤´é¹°å¤´çŒ«'
                ],
                'ğŸ› é”™è¯¯æ¼”ç¤º (å¯è§†åŒ–æµ‹è¯•)': [
                    'çŒ«å¤´',          // âŒ è¯­å¥æœªå®Œæˆ
                    'çŒ«å¤´ç‹—',        // âŒ æœªçŸ¥å­—ç¬¦ "ç‹—"
                    'çŒ«å¤´Xé¹°',       // âŒ ä¸­é—´åŒ…å«éæ³•å­—ç¬¦
                    'çŒ«å¤´é¹°çŒ«',      // âŒ ç»“å°¾å¤šä½™æˆåˆ†
                    'å¤´çŒ«'           // âŒ é”™è¯¯çš„å¼€å¤´
                ]
            };

            let html = '<div style="margin-top:10px">';
            for (const [category, examples] of Object.entries(categories)) {
                html += `<div class="category-title">${category}:</div>`;
                html += '<div class="examples-grid">';
                html += examples.map(exp =>
                    `<button class="example-btn" onclick="document.getElementById('inputText').value='${exp}'; parseInput()">${exp}</button>`
                ).join('');
                html += '</div>';
            }
            html += '</div>';
            document.getElementById('message').innerHTML = html;
        }

        // åˆå§‹åŒ–
        window.onload = function() { parseInput(); };
    </script>
</body>
</html>
